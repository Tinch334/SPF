\config{vertmargin}[margin: 40]
\config{hozmargin}[margin: 40]

\config{titlesize}[size: 42]
\config{parsize}[size: 12]
\config{subsectionsize}[size: 15]

\config{parindent}[indent: 25]
\config{sectionspacing}[before: 5, after: 5]
\config{paragraphspacing}[before: 5, after: 10]

\config{sectionnumbering}[numbering: false]


\title{Simple PDF}
\author{Martín Goñi}
\date{2\/2\/2026}


\section{¿Que es \bold{SPF}?}
Simple PDF, es un DSL para generar PDFs, es decir un lenguaje que al ser interpretado produce PDFs, este informe está hecho con \bold{SPF}. Decidí hacer \bold{SPF} porque me interesaba que el proyecto hiciese algo más que dar salida a la consola. Considerando que desde que conocí \bold{LaTeX} me interesó el typesetting este proyecto era la excusa ideal para interiorizarme más en el tema.

\subsection{Consideraciones de diseño}
A la hora de diseñar \bold{SPF} me inspire en \bold{LaTeX}, pero sin mantenerme atado a sus convenciones o decisiones de diseño, lo trate como una fuente de inspiración. En particular toma otra dirección en cuanto a la forma de los comandos, permitiendo solo un argumento; Al mismo tiempo las opciones deben tener asociada una clave indicando a qué corresponde el valor. Finalmente simplifique la forma en la que estructura el documento, ya no es necesario separar el título y documento de forma explícita.

Los comandos implementados son un subconjunto de los disponibles en \bold{LaTeX}, elegidos para permitir generar documentos (mayormente)completos, manteniendo al mismo tiempo la cantidad total de comandos baja.

\subsection{Sintaxis}
Para representar la sintaxis se usan ciertas convenciones; El símbolo \bold{*} indica cero o más ocurrencias de lo que encierra mientras que el \bold{+} indica una o mas ocurrencias. Los comentarios no están incluidos pues no son parte de la sintaxis en si, son añadidos en el parser para la conveniencia del usuario. A continuación se presenta la sintaxis concreta de \bold{SPF}:

\begin{verbatim}[numbering: false]
digit           ::= '0' | '1' | ... | '9'
integer         ::= <digit> (<digit>)*
float           ::= <integer> '.' <integer>
letter          ::= 'a' | ... | 'z' | 'A' | ... | 'Z'
letterStr       ::= <letter> (<letter>)*
specialChars    ::= '\' | '{', '}' | '[' | ']' | '"' | '/' | '|'
nonSpecialChars ::= c / c != <specialChars>
filepath        ::= (<letterStr> | '/' | '\' | '-' | '_' | '.' | ' ')+

#| Opciones
optionList      ::= '[' optionListElems ']'
optionListElems ::= <optionPair> (',' <optionPair>)*
optionPair      ::= <letterStr> ':' <optionValue>
optionValue     ::= <boolValue> 
                | <numberValue>
                | <literalValue>
                | <identifierValue>

boolValue       ::= 'true' | 'false'
numberValue     ::= <integer> | <float>
literalValue    ::= '"' <nonSpecialChars> '"'
identifierValue ::= <letterStr>

#| Texto
text        ::= ('\bold' | '\italic' | '\emph') '{' <textChars> '}'
textChars   ::= (<nonSpecialChars>)+ <textChars> | '\' <specialChars> <textChars> | <empty>

#| Configuración del documento
config      ::= '\config{' <configName> '}' <optionList>
configName  ::= 'size' | 'pagenumbering' | ... | 'verbatimnumbering'

#| Metadata del documento
metadata    ::= <title> <author> <date>
title       ::= '\title{' <text> '}' | <empty>
author      ::= '\author{' <text> '}' | <empty>
date        ::= '\date{' <text> '}' | <empty>

#| Comandos
command ::= <text>
        | <paragraph>
        | <section>
        | <subsection>
        | <figure>
        | <table>
        | <list>
        | <verbatim>
        | <newpage>
        | <hline>

paragraph         ::= '\begin{paragraph}' <optionList> <text> '\end{paragraph}'
section           ::= '\section{'<text> '}' <optionList>
subsection        ::= '\subsection{'<text> '}' <optionList>
figure            ::= '\figure{' <filepath> '}' <optionList>
table             ::= '\begin{table}' <optionList> <tableContents> '\end{table}'
tableContents     ::= <text> ('|' <text>)* '\break'
list              ::= '\begin{list}' <optionList> <listContents> '\end{list}'
listContents      ::= '\item' <text>
verbatim          ::= '\begin{verbatim}' <optionList> <verbatimContents> '\end{verbatim}'
verbatimContents  ::= (<anyChar>)+ (<notFollowedBy> '\end')>
newpage           ::= '\newpage'
hline             ::= '\hline' <optionList>

#| Documento
document    ::= (<config>)* <metadata> (<command>)+
\end{verbatim}

\section{Funcionamiento}
Para mantener el sistema lo más modular posible \bold{SPF} está dividido en componentes, cada una independiente de las demás. Dado un archivo en formato \bold{SPF} este atraviesa una serie de módulos para producir un PDF, en orden, son:

\begin{list}[style: number]
\item Parser: Se encuentra en \bold{Parser.hs}. Se encarga de \italic{parsear} el archivo, es decir convertir el texto del mismo en un AST. Cabe notar que en este punto no se validan los datos, el parser solo se ocupa de la correctitud \italic{sintáctica} del archivo, no la \italic{semántica}. Puede fallar.
\item Validador: Está compuesto por múltiples archivos, se encuentran en el directorio \bold{Validation}. Valida los contenidos del AST generado por el parser. El trabajo principal del validador es verificar que las opciones en el archivo, tanto de configuración como de los comandos sean correctas; Esto conlleva verificar que cada par \bold{clave:valor} sea del tipo y forma correcta para el comando o la configuración a él que corresponden. Devuelve otro AST y puede fallar.
\item Recursos: Se encuentra en \bold{Resources.hs}. Carga todos los recursos necesarios para typesetter el documento. Por un lado están las fuentes, siempre deben cargarse. Por el otro lado están los recursos especificados por el usuario, deben ser cargados antes de comenzar a typsetear el documento, esta carga pude fallar.
\end{list}

\subsection{Un poco más sobre ASTs}
En un principio los ASTs usados simplemente almacenaban una lista de todos los comandos utilizados en el documento. Rapidamente me di cuenta de que esto era una mala idea. En primer lugar no habia separacion entre tipos de datos, todos eran \italic{comandos} en una lista. Lo que llevaba a un segundo problema era necesario iterar repetidas veces sobre esta lista para obtener distintos tipos de comandos (Configuracion, metadata, etc). Hacer esto es ineficiente y no escala bien. Para solucionar esto los ASTs se separaron en componentes funcionales, donde cada una responde a un tipo de comando. De esta forma solo se itera sobre una lista cuando es necesario recorrerla.

\subsection{¿Como fallar?}
Cómo manejar fallos en un programa de este tipo no es una pregunta facil de resolver, principalmente porque es posible tener \italic{muchos} fallos. Seria entonces ideal poder acumular todos los errores que ocurren mientras el programa procesa un archivo. Esto sin embargo no es posible, al menos del todo. No se pueden acumular errores de distintas secciones pues cada módulo depende de que el resultado de los anteriores sea correcto. Llegamos así a un compromiso, si bien no podemos acumular \italic{todos} los errores a lo largo del programa si podemos acumular los errores de cada etapa. Esto es más eficiente, pues le permite solucionar múltiples problemas al mismo tiempo, haciendo que se deba ejecutar el programa menos veces.

En el parser esto se hace usando \italic{delayed parse errors}. Estos son errores que no provocan que el parser falle inmediatamente, los errores acumulados se toman en cuenta al final del paseo, donde sí hay por lo menos uno el parser falla. Cabe notar que es posible obtener un error \"normal\", haciendo que el parser falle inmediatamente, esto ocurre ya que los \italic{delayed parse errors} deben implementarse manualmente, uno a uno; Por lo tanto no es posible cubrir todos los casos posibles, se cubrieron los errores mas comunes y fáciles de producir.

El resto de los módulos utiliza el paquete \bold{Validation}, su descripción es bastante autoexplicativa: \italic{A data-type like Either but with an accumulating Applicative}. Es decir cumple la misma función que \bold{either}, dándonos un resultado o un error, pero permitiéndonos acumular errores. Para que esto sea posible el tipo de datos del error debe ser un semigrupo, en este caso se usa una lista de \bold{LocatedError}, son errores que contienen la ubicación aproximada, indicando que parte del archivo provocó el error.

\subsection{Generando PDFs}
Una vez que se tiene un AST valido falta la parte mas importante, transformarlo en un PDF. Para hacer esto utilice la libreria \bold{HPDF}. Elegi esta libreria por un motivo simple, es la unica libreria para generar PDFs escrita en Haskell.

Habiendo usado esta libreria puedo decir que si bien es muy poderosa \italic{tiene problemas}, el principal y del cual derivan la mayoria es que es una libreria con muy pocos usuarios. Como consequencia de esto hay muy poca informacion sobre la libreria. La documentacion esta incompleta, muchas funciones tienen explicaciones muy pobres, si es que tienen. Sumado a esto nunca se explica la estructura o flujo general de un programa hecho con \bold{HPDF}, ni como se conectan los distintos componentes de la libreria.

Lo que me permitio entender como funciona la libreria fue el archivo de prueba(\bold{Test/test.hs}) en el repositorio del proyecto. Este prueba casi todas las funciones de la libreria generando un documento. Me permitio ver un ejemplo en funcionamiento de la misma al mismo tiempo que me permitia expermientar y realizar cambios para ver \italic{exactamente} como funcionaba la libreria.

\subsection{Un error en HPDF}
\figure{Img/WidthError.png}[width: 0.85, caption: "Un ejemplo del error"]